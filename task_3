#include <SFML/Graphics.hpp>
#include <time.h>
#include <list>
#include <random>
#include<String>
#include <cmath>


using namespace sf;

//width of window
const int W = 1200;
//hight of window
const int H = 800;
const int Res = 20;
//dergees to radians
float DEGTORAD = 0.017453f;

//numbers 
int n_Entities = 200;
int r_r = 5;
//returns mersenne()
int f_rand() {

    std::random_device rd;
    std::mt19937 mersenne(rd());

    //return mersenne();
    return rand();
}


class Entity
{
public:
    float x, y,
          dx, dy,
          R;


    Entity()
    {   
        x = f_rand() % W;
        y = f_rand() % H;

        dx = f_rand() % 7 - 3;
        dy = f_rand() % 7 - 3;
      
        R = r_r;
    }


    void move() {

        x += dx;
        y += dy;

        if ((x > W - r_r) || (x < r_r))  dx = -dx;  
        if ((y > H - r_r) || (y < r_r))  dy = -dy;

     
    };

   


    virtual void update() { 
        move();    
    };

    void draw(RenderWindow& app)
    {       
        //hitbox
        CircleShape circle(R);
        circle.setFillColor(Color(255, 255, 0, 170));
        circle.setPosition(x, y);
        circle.setOrigin(R, R);
        app.draw(circle);

    }

    virtual ~Entity() {};
};

class Background {

private:
    int m_res;
    std::vector < sf::Color > m_colors;
    std::vector <std::vector<int>> m_numbers;

    int m_width;
    int m_height;
    int m_max;

    sf::Image m_image;
    sf::Sprite m_sprite;
    sf::Texture m_texture;

public:
  
    Background(const int res_, const int width, const int height) {
        m_res = res_;
        m_width = width;
        m_height = height;
        //m_sprite.setOrigin(-width / 2, -height / 2);
       

        const int x_num = width / m_res;
        const int y_num = height / m_res;


        for (auto i = 0; i <= x_num; i++) {
            m_numbers.push_back(std::vector <int>(y_num));
        }

        m_colors.assign({
           sf::Color(18, 40, 61), //0
           sf::Color(10, 72, 101),//1 - 1/4m
           sf::Color(177, 61, 36),//1/4 m - 2/4m
           sf::Color(246, 180, 36),//2/4 m - 3/4 m
           sf::Color(252, 248,231),//3/4 m - m
        });

        m_image.create(width, height, sf::Color(0, 255, 255));    
        m_texture.loadFromImage(m_image);
        m_sprite.setTexture(m_texture, true);
      
    }

    void calculate(std::list<Entity*> & entities) {

        //res - number of pixels per squarev
        for (auto vec_x : m_numbers) {
            for (auto y : vec_x) {
                y = 0;
            }
        }
        
        for (auto e : entities) {
           int x_i = e->x / m_res;
           int y_i = e->y / m_res;
           int a =  m_numbers[x_i][y_i];
           (m_numbers[x_i][y_i])++;
        }

        m_max = 0;

        for (auto vec_x : m_numbers) {
            for (auto y : vec_x) {
                if (y > m_max) m_max = y;
            }
        }     

        paint();

    }

    void paint() {

        for (int x = 0; x < m_width; x++) {
            for (int y = 0; y < m_height; y++) {

                int x_i = x / m_res;
                int y_i = y / m_res;

                m_image.setPixel(x, y, m_colors[static_cast <std::size_t>(1.0f * m_numbers[x_i][y_i] / m_max * (m_colors.size() - 1))]); // ?
            }
        }

        m_texture.loadFromImage(m_image);
        m_sprite.setTexture(m_texture, true);
    }

    Sprite* sprite() { return &m_sprite; }

};




bool isCollide(Entity* a, Entity* b)
{   
    if (a != b) {
        return (b->x - a->x) * (b->x - a->x) +
            (b->y - a->y) * (b->y - a->y) <
            4 * r_r * r_r;
    }
    else return false;
}

void calc_collide(Entity* a, Entity* b) {

   /* float v_a = sqrt(a->dx * a->dx + a->dy + a->dy);
    float v_b = sqrt(b->dx * b->dx + b->dy + b->dy);

    float phi = atan((a->y - b->y) / (a->x - b->x));
    float theta_a = atan(a->dy / a->dx);
    float theta_b = atan(b->dy / b->dx);

    a->dx = v_b * cos(theta_b - phi) * cos(phi);
    a->dy = v_b * cos(theta_b - phi) * sin(phi);
    b->dx = v_a * cos(theta_a - phi) * cos(phi);
    b->dy = v_a * cos(theta_a - phi) * sin(phi);*/

    
   float n_x = a->x - b->x;
   float n_y = a->y - b->y;
   
   float n = n_x * n_x + n_y * n_y;
  

   float a_x = a->dx;
   float a_y = a->dy;

   float b_x = b->dx;
   float b_y = b->dy;

   float a_a = sqrt(a_x * a_x + a_y * a_y);
   float b_b = sqrt( b_x * b_x + b_y * b_y);

   /* a->dx +=   2 * n_x * (a_x * n_x + a_y * n_y) / (n_x * n_x + n_y * n_y);
    a->dy +=   2 * n_y * (a_x * n_x + a_y * n_y) / (n_x * n_x + n_y * n_y);

    b->dx +=   2 * n_x * (b_x * n_x + b_y * n_y) / (n_x * n_x + n_y * n_y);
    b->dy +=   2 * n_y * (b_x * n_x + b_y * n_y) / (n_x * n_x + n_y * n_y);*/

   a_a = 15 + f_rand() % 10;
   b_b = 15 + f_rand() % 10;

   a->dx = n_x/n * b_b;
   a->dy = n_y/n  *b_b;
   b->dx = -n_x/n *a_a;
   b->dy = -n_y/n * a_a;

}

int main()
{   
    srand(time(NULL));
    
    RenderWindow app(VideoMode(W, H), "particles");
    app.setFramerateLimit(60);

    Background background(Res, W, H);


    std::list<Entity*> entities;
    //initial spawn
    for (int i = 0; i < n_Entities; i++)
    {
        Entity* a = new Entity();
        entities.push_back(a);
    }



    /////main loop/////
    while (app.isOpen())
    {
        Event event;
        while (app.pollEvent(event))
        {
            if (event.type == Event::Closed)
                app.close();
                     
        }     

        for (auto a : entities) {
            for (auto b : entities)
            {
                if (isCollide(a, b))
                {              

                    calc_collide(a, b);
                                    
                }

            }

        }
      

        for (auto i = entities.begin();i != entities.end(); i++)
        {
            Entity* e = *i;

            e->update();
           
        }
        
        background.calculate(entities);
       

        //////draw//////
       // app.clear(Color(100, 220, 100, 100));

        app.draw(*background.sprite());

        for (auto i : entities) i->draw(app);

        //app.clear(Color(100, 220, 100, 100));
        app.display();


    }

    return 0;
}
